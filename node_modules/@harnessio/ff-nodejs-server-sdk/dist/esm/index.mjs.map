{
  "version": 3,
  "sources": ["../../node_modules/jwt-decode/lib/atob.js", "../../node_modules/jwt-decode/lib/base64_url_decode.js", "../../node_modules/jwt-decode/lib/index.js", "../../node_modules/jwt-decode/lib/index.cjs.js", "../../node_modules/is-retry-allowed/index.js", "../../node_modules/axios-retry/es/index.js", "../../node_modules/axios-retry/index.js", "../../node_modules/retry/lib/retry_operation.js", "../../node_modules/retry/lib/retry.js", "../../node_modules/retry/index.js", "../../node_modules/@harnessio/eventsource/lib/eventsource.js", "../../node_modules/yallist/iterator.js", "../../node_modules/yallist/yallist.js", "../../node_modules/lru-cache/index.js", "../../node_modules/murmurhash/murmurhash.js", "../../src/client.ts", "../../src/types.ts", "../../src/openapi/api.ts", "../../src/openapi/base.ts", "../../src/openapi/common.ts", "../../src/openapi/configuration.ts", "../../src/version.ts", "../../src/polling.ts", "../../src/streaming.ts", "../../src/constants.ts", "../../src/log.ts", "../../src/store.ts", "../../src/evaluator.ts", "../../src/repository.ts", "../../src/metrics.ts", "../../src/index.ts"],
  "sourcesContent": ["/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction InvalidCharacterError(message) {\n    this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n\nfunction polyfill(input) {\n    var str = String(input).replace(/=+$/, \"\");\n    if (str.length % 4 == 1) {\n        throw new InvalidCharacterError(\n            \"'atob' failed: The string to be decoded is not correctly encoded.\"\n        );\n    }\n    for (\n        // initialize result and counters\n        var bc = 0, bs, buffer, idx = 0, output = \"\";\n        // get next character\n        (buffer = str.charAt(idx++));\n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n        ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ?\n        (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n        0\n    ) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n    }\n    return output;\n}\n\nexport default (typeof window !== \"undefined\" &&\n    window.atob &&\n    window.atob.bind(window)) ||\npolyfill;", "import atob from \"./atob\";\n\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(\n        atob(str).replace(/(.)/g, function(m, p) {\n            var code = p.charCodeAt(0).toString(16).toUpperCase();\n            if (code.length < 2) {\n                code = \"0\" + code;\n            }\n            return \"%\" + code;\n        })\n    );\n}\n\nexport default function(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (err) {\n        return atob(output);\n    }\n}", "\"use strict\";\n\nimport base64_url_decode from \"./base64_url_decode\";\n\nexport function InvalidTokenError(message) {\n    this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nexport default function(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified\");\n    }\n\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: \" + e.message);\n    }\n}", "import jwtDecode, { InvalidTokenError } from \"./index\";\n\nconst wrapper = jwtDecode;\nwrapper.default = jwtDecode;\nwrapper.InvalidTokenError = InvalidTokenError;\nexport default wrapper;", "'use strict';\n\nvar WHITELIST = [\n\t'ETIMEDOUT',\n\t'ECONNRESET',\n\t'EADDRINUSE',\n\t'ESOCKETTIMEDOUT',\n\t'ECONNREFUSED',\n\t'EPIPE',\n\t'EHOSTUNREACH',\n\t'EAI_AGAIN'\n];\n\nvar BLACKLIST = [\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED'\n];\n\nmodule.exports = function (err) {\n\tif (!err || !err.code) {\n\t\treturn true;\n\t}\n\n\tif (WHITELIST.indexOf(err.code) !== -1) {\n\t\treturn true;\n\t}\n\n\tif (BLACKLIST.indexOf(err.code) !== -1) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n", "import isRetryAllowed from 'is-retry-allowed';\n\nconst namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  return (\n    !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests\n    isRetryAllowed(error)\n  ); // Prevents retrying unsafe errors\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return (\n    error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n  );\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean | Promise}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * @param  {number} [retryNumber=0]\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0) {\n  const delay = Math.pow(2, retryNumber) * 100;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\nfunction getCurrentState(config) {\n  const currentState = config[namespace] || {};\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace]);\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Checks retryCondition if request can be retried. Handles it's retruning value or Promise.\n * @param  {number} retries\n * @param  {Function} retryCondition\n * @param  {Object} currentState\n * @param  {Error} error\n * @return {boolean}\n */\nasync function shouldRetry(retries, retryCondition, currentState, error) {\n  const shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);\n\n  // This could be a promise\n  if (typeof shouldRetryOrPromise === 'object') {\n    try {\n      await shouldRetryOrPromise;\n      return true;\n    } catch (_err) {\n      return false;\n    }\n  }\n  return shouldRetryOrPromise;\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  axios.interceptors.request.use(config => {\n    const currentState = getCurrentState(config);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  axios.interceptors.response.use(null, async error => {\n    const config = error.config;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const {\n      retries = 3,\n      retryCondition = isNetworkOrIdempotentRequestError,\n      retryDelay = noDelay,\n      shouldResetTimeout = false\n    } = getRequestOptions(config, defaultOptions);\n\n    const currentState = getCurrentState(config);\n\n    if (await shouldRetry(retries, retryCondition, currentState, error)) {\n      currentState.retryCount += 1;\n      const delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)\n        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);\n      }\n\n      config.transformRequest = [data => data];\n\n      return new Promise(resolve => setTimeout(() => resolve(axios(config)), delay));\n    }\n\n    return Promise.reject(error);\n  });\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n", "module.exports = require('./lib/index').default;", "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "var parse = require('url').parse\nvar events = require('events')\nvar https = require('https')\nvar http = require('http')\nvar util = require('util')\nvar retry = require('retry')\n\nvar httpsOptions = [\n  'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers',\n  'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'\n]\n\nvar bom = [239, 187, 191]\nvar colon = 58\nvar space = 32\nvar lineFeed = 10\nvar carriageReturn = 13\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i\n\nfunction hasBom (buf) {\n  return bom.every(function (charCode, index) {\n    return buf[index] === charCode\n  })\n}\n\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/\nfunction EventSource (url, eventSourceInitDict) {\n  var readyState = EventSource.CONNECTING\n  var headers = eventSourceInitDict && eventSourceInitDict.headers\n  var hasNewOrigin = false\n  Object.defineProperty(this, 'readyState', {\n    get: function () {\n      return readyState\n    }\n  })\n\n  Object.defineProperty(this, 'url', {\n    get: function () {\n      return url\n    }\n  })\n\n  var self = this\n  self.reconnectInterval = 1000\n\n  function scheduleReconnect () {\n    // The url may have been changed by a temporary redirect. If that's the case,\n    // revert it now, and flag that we are no longer pointing to a new origin\n    if (reconnectUrl) {\n      url = reconnectUrl\n      reconnectUrl = null\n      hasNewOrigin = false\n    }\n\n    // First scenario covering 30 seconds of retries.\n    // Uses backoff and randomized timeouts.\n    var shortTermStrategy = retry.operation({\n      retries: 15,\n      factor: 2,\n      minTimeout: 1000,\n      maxTimeout: 3000,\n      randomize: true\n    })\n\n    // This scenario is for long term retries, which tries to connect forever, as long as the error\n    // is retryable. Uses an exponential backoff and randomizes the timeouts.\n    var longTermStrategy = retry.operation({\n      forever: true,\n      factor: 3,\n      minTimeout: 300000,\n      maxTimeout: 300000,\n      randomize: true\n    })\n\n    function attemptRetries () {\n      // Check if we're in a closed state before proceeding with any retries.\n      if (readyState === EventSource.CLOSED) return\n      shortAndLongTermRetryAttempt()\n    }\n\n    function shortAndLongTermRetryAttempt () {\n      shortTermStrategy.attempt(function (currentAttempt) {\n        // Unlike the long term strategies, we emit the retrying event before\n        // checking if we're in a retrying state, which ensures we always fire off the initial retrying event.\n        // The check for if we're in a closed state covers us for subsequent retries.\n        _emit('retrying', new Event('retrying', { shortTermRetryAttempt: currentAttempt }))\n        if (readyState !== EventSource.RETRYING) return\n        connect()\n        if (shortTermStrategy.retry(readyState === EventSource.RETRYING)) {\n          return\n        }\n        if (readyState !== EventSource.RETRYING) {\n          return\n        }\n\n        longTermAttempt()\n      })\n    }\n\n    function longTermAttempt () {\n      longTermStrategy.attempt(function (currentAttempt) {\n        // It's feasible, if unlikely, a user can close a connection themselves after the library starts retrying.\n        // So unlike the short term strategy, only emit the retrying event after this check.\n        if (readyState !== EventSource.RETRYING) return\n        _emit('retrying', new Event('retrying', { longTermRetryAttempt: currentAttempt }))\n        connect()\n        longTermStrategy.retry(readyState === EventSource.RETRYING)\n      })\n    }\n\n    attemptRetries()\n  }\n\n  function isRetryableError (error) {\n    if (error) {\n      if (error.status) {\n        var status = error.status\n        return status === 500 || status === 502 || status === 503 || status === 504\n      }\n    }\n    // Always retry on IO Errors\n    return true\n  }\n\n  function onConnectionFailed (error) {\n    if (readyState === EventSource.CLOSED) {\n      return\n    }\n    var errorEvent = new Event('error', { error: error })\n    // Emit the error here before we check if we're in a retrying state, in case the error has changed during our retries\n    // e.g. from a 502 to a 500.\n    _emit('retrying', new Event('retrying', { error: error }))\n    if (isRetryableError(error)) {\n      // If we're already in the midst of a retry then return to avoid\n      // infinitely recursive retries.\n      if (readyState === EventSource.RETRYING) {\n        return\n      }\n\n      readyState = EventSource.RETRYING\n      scheduleReconnect(error)\n    } else {\n      readyState = EventSource.CLOSED\n      _emit('error', errorEvent)\n\n      // TODO we don't do anything with this event in the SDK. I think we should remove it, as this is the only\n      //  place we emit `closed` and it's emitted for the same reason as an error.\n      _emit('closed', new Event('closed'))\n    }\n  }\n\n  var req\n  var lastEventId = ''\n  if (headers && headers['Last-Event-ID']) {\n    lastEventId = headers['Last-Event-ID']\n    delete headers['Last-Event-ID']\n  }\n\n  var discardTrailingNewline = false\n  var data = ''\n  var eventName = ''\n\n  var reconnectUrl = null\n\n  function connect () {\n    var options = parse(url)\n    var isSecure = options.protocol === 'https:'\n    options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' }\n    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId\n    if (headers) {\n      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers\n      for (var i in reqHeaders) {\n        var header = reqHeaders[i]\n        if (header) {\n          options.headers[i] = header\n        }\n      }\n    }\n\n    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n    // but for now exists as a backwards-compatibility layer\n    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized)\n\n    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n      options.createConnection = eventSourceInitDict.createConnection\n    }\n\n    // If specify http proxy, make the request to sent to the proxy server,\n    // and include the original url in path and Host headers\n    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy\n    if (useProxy) {\n      var proxy = parse(eventSourceInitDict.proxy)\n      isSecure = proxy.protocol === 'https:'\n\n      options.protocol = isSecure ? 'https:' : 'http:'\n      options.path = url\n      options.headers.Host = options.host\n      options.hostname = proxy.hostname\n      options.host = proxy.host\n      options.port = proxy.port\n    }\n\n    // If https options are specified, merge them into the request options\n    if (eventSourceInitDict && eventSourceInitDict.https) {\n      for (var optName in eventSourceInitDict.https) {\n        if (httpsOptions.indexOf(optName) === -1) {\n          continue\n        }\n\n        var option = eventSourceInitDict.https[optName]\n        if (option !== undefined) {\n          options[optName] = option\n        }\n      }\n    }\n\n    // Pass this on to the XHR\n    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n      options.withCredentials = eventSourceInitDict.withCredentials\n    }\n\n    req = (isSecure ? https : http).request(options, function (res) {\n      // Handle HTTP errors\n      if (res.statusCode >= 400 && res.statusCode <= 599) {\n        onConnectionFailed({ status: res.statusCode, message: res.statusMessage })\n        return\n      }\n\n      // Handle HTTP redirects\n      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n        var location = res.headers.location\n        if (!location) {\n          // Server sent redirect response without Location header.\n          onConnectionFailed({ status: res.statusCode, message: res.statusMessage })\n          return\n        }\n        var prevOrigin = new URL(url).origin\n        var nextOrigin = new URL(location).origin\n        hasNewOrigin = prevOrigin !== nextOrigin\n        if (res.statusCode === 307) reconnectUrl = url\n        url = location\n        process.nextTick(connect)\n        return\n      }\n\n      if (res.statusCode >= 400 && res.statusCode <= 599) {\n        _emit('error', new Event('error', { status: res.statusCode, message: res.statusMessage }))\n        return self.close()\n      }\n\n      readyState = EventSource.OPEN\n      res.on('close', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionFailed({ message: 'server closed the connection' })\n      })\n\n      res.on('end', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionFailed({ message: 'server ended the connection' })\n      })\n      _emit('open', new Event('open'))\n\n      // text/event-stream parser adapted from webkit's\n      // Source/WebCore/page/EventSource.cpp\n      var buf\n      var newBuffer\n      var startingPos = 0\n      var startingFieldLength = -1\n      var newBufferSize = 0\n      var bytesUsed = 0\n\n      res.on('data', function (chunk) {\n        if (!buf) {\n          buf = chunk\n          if (hasBom(buf)) {\n            buf = buf.slice(bom.length)\n          }\n          bytesUsed = buf.length\n        } else {\n          if (chunk.length > buf.length - bytesUsed) {\n            newBufferSize = (buf.length * 2) + chunk.length\n            if (newBufferSize > maxBufferAheadAllocation) {\n              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation\n            }\n            newBuffer = Buffer.alloc(newBufferSize)\n            buf.copy(newBuffer, 0, 0, bytesUsed)\n            buf = newBuffer\n          }\n          chunk.copy(buf, bytesUsed)\n          bytesUsed += chunk.length\n        }\n\n        var pos = 0\n        var length = bytesUsed\n\n        while (pos < length) {\n          if (discardTrailingNewline) {\n            if (buf[pos] === lineFeed) {\n              ++pos\n            }\n            discardTrailingNewline = false\n          }\n\n          var lineLength = -1\n          var fieldLength = startingFieldLength\n          var c\n\n          for (var i = startingPos; lineLength < 0 && i < length; ++i) {\n            c = buf[i]\n            if (c === colon) {\n              if (fieldLength < 0) {\n                fieldLength = i - pos\n              }\n            } else if (c === carriageReturn) {\n              discardTrailingNewline = true\n              lineLength = i - pos\n            } else if (c === lineFeed) {\n              lineLength = i - pos\n            }\n          }\n\n          if (lineLength < 0) {\n            startingPos = length - pos\n            startingFieldLength = fieldLength\n            break\n          } else {\n            startingPos = 0\n            startingFieldLength = -1\n          }\n\n          parseEventStreamLine(buf, pos, fieldLength, lineLength)\n\n          pos += lineLength + 1\n        }\n\n        if (pos === length) {\n          buf = void 0\n          bytesUsed = 0\n        } else if (pos > 0) {\n          buf = buf.slice(pos, bytesUsed)\n          bytesUsed = buf.length\n        }\n      })\n    })\n\n    req.on('error', function (err) {\n      onConnectionFailed(err.message)\n    })\n    // FF Server sends keepalive messages every 20 seconds, so timeout on 30 seconds to account for latency.\n    var timeout = 30000\n    req.setTimeout(timeout)\n\n    req.on('timeout', function () {\n      onConnectionFailed({\n        message: `Read timeout, received no data in ${timeout}ms, assuming connection is dead`\n      })\n    })\n\n    if (req.setNoDelay) req.setNoDelay(true)\n    req.end()\n  }\n\n  connect()\n\n  function _emit () {\n    if (self.listeners(arguments[0]).length > 0) {\n      self.emit.apply(self, arguments)\n    }\n  }\n\n  this._close = function () {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CLOSED\n    if (req.abort) req.abort()\n    if (req.xhr && req.xhr.abort) req.xhr.abort()\n    _emit('closed', new Event('closed'))\n  }\n\n  function parseEventStreamLine (buf, pos, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        var type = eventName || 'message'\n        _emit(type, new MessageEvent(type, {\n          data: data.slice(0, -1), // remove trailing newline\n          lastEventId: lastEventId,\n          origin: new URL(url).origin\n        }))\n        data = ''\n      }\n      eventName = void 0\n    } else if (fieldLength > 0) {\n      var noValue = fieldLength < 0\n      var step = 0\n      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString()\n\n      if (noValue) {\n        step = lineLength\n      } else if (buf[pos + fieldLength + 1] !== space) {\n        step = fieldLength + 1\n      } else {\n        step = fieldLength + 2\n      }\n      pos += step\n\n      var valueLength = lineLength - step\n      var value = buf.slice(pos, pos + valueLength).toString()\n\n      if (field === 'data') {\n        data += value + '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id') {\n        lastEventId = value\n      }\n    }\n  }\n}\n\nmodule.exports = EventSource\n\nutil.inherits(EventSource, events.EventEmitter)\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n\n['open', 'error', 'retrying', 'closed', 'message'].forEach(function (method) {\n  Object.defineProperty(EventSource.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    get: function get () {\n      var listener = this.listeners(method)[0]\n      return listener ? (listener._listener ? listener._listener : listener) : undefined\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    set: function set (listener) {\n      this.removeAllListeners(method)\n      this.addEventListener(method, listener)\n    }\n  })\n})\n\n/**\n * Ready states\n */\nObject.defineProperty(EventSource, 'CONNECTING', { enumerable: true, value: 0 })\nObject.defineProperty(EventSource, 'OPEN', { enumerable: true, value: 1 })\nObject.defineProperty(EventSource, 'CLOSED', { enumerable: true, value: 2 })\nObject.defineProperty(EventSource, 'RETRYING', { enumerable: true, value: 3 })\n\nEventSource.prototype.CONNECTING = 0\nEventSource.prototype.OPEN = 1\nEventSource.prototype.CLOSED = 2\nEventSource.prototype.RETRYING = 3\n\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */\nEventSource.prototype.close = function () {\n  this._close()\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.addEventListener = function addEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    // store a reference so we can return the original function again\n    listener._listener = listener\n    this.on(type, listener)\n  }\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */\nEventSource.prototype.dispatchEvent = function dispatchEvent (event) {\n  if (!event.type) {\n    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR')\n  }\n\n  this.emit(event.type, event)\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.removeEventListener = function removeEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    listener._listener = undefined\n    this.removeListener(type, listener)\n  }\n}\n\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */\nfunction Event (type, optionalProperties) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  if (optionalProperties) {\n    for (var f in optionalProperties) {\n      if (optionalProperties.hasOwnProperty(f)) {\n        Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true })\n      }\n    }\n  }\n}\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */\nfunction MessageEvent (type, eventInitDict) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  for (var f in eventInitDict) {\n    if (eventInitDict.hasOwnProperty(f)) {\n      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true })\n    }\n  }\n}\n\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */\nfunction removeUnsafeHeaders (headers) {\n  var safe = {}\n  for (var key in headers) {\n    if (reUnsafeHeader.test(key)) {\n      continue\n    }\n\n    safe[key] = headers[key]\n  }\n\n  return safe\n}\n", "'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n", "'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n", "'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n", "(function(){\r\n  var _global = this;\r\n\r\n  const createBuffer = (val) => new TextEncoder().encode(val)\r\n\r\n  /**\r\n   * JS Implementation of MurmurHash2\r\n   *\r\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n   * @see http://github.com/garycourt/murmurhash-js\r\n   * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\r\n   * @see http://sites.google.com/site/murmurhash/\r\n   *\r\n   * @param {Uint8Array | string} str ASCII only\r\n   * @param {number} seed Positive integer only\r\n   * @return {number} 32-bit positive integer hash\r\n   */\r\n  function MurmurHashV2(str, seed) {\r\n    if (typeof str === 'string') str = createBuffer(str);\r\n    var\r\n      l = str.length,\r\n      h = seed ^ l,\r\n      i = 0,\r\n      k;\r\n\r\n    while (l >= 4) {\r\n      k =\r\n        ((str[i] & 0xff)) |\r\n        ((str[++i] & 0xff) << 8) |\r\n        ((str[++i] & 0xff) << 16) |\r\n        ((str[++i] & 0xff) << 24);\r\n\r\n      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\r\n      k ^= k >>> 24;\r\n      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\r\n\r\n    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\r\n\r\n      l -= 4;\r\n      ++i;\r\n    }\r\n\r\n    switch (l) {\r\n    case 3: h ^= (str[i + 2] & 0xff) << 16;\r\n    case 2: h ^= (str[i + 1] & 0xff) << 8;\r\n    case 1: h ^= (str[i] & 0xff);\r\n            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\r\n    }\r\n\r\n    h ^= h >>> 13;\r\n    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\r\n    h ^= h >>> 15;\r\n\r\n    return h >>> 0;\r\n  };\r\n\r\n  /**\r\n   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\r\n   *\r\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n   * @see http://github.com/garycourt/murmurhash-js\r\n   * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\r\n   * @see http://sites.google.com/site/murmurhash/\r\n   *\r\n   * @param {Uint8Array | string} key ASCII only\r\n   * @param {number} seed Positive integer only\r\n   * @return {number} 32-bit positive integer hash\r\n   */\r\n  function MurmurHashV3(key, seed) {\r\n    if (typeof key === 'string') key = createBuffer(key);\r\n\r\n    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\r\n\r\n    remainder = key.length & 3; // key.length % 4\r\n    bytes = key.length - remainder;\r\n    h1 = seed;\r\n    c1 = 0xcc9e2d51;\r\n    c2 = 0x1b873593;\r\n    i = 0;\r\n\r\n    while (i < bytes) {\r\n        k1 =\r\n          ((key[i] & 0xff)) |\r\n          ((key[++i] & 0xff) << 8) |\r\n          ((key[++i] & 0xff) << 16) |\r\n          ((key[++i] & 0xff) << 24);\r\n      ++i;\r\n\r\n      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\r\n      k1 = (k1 << 15) | (k1 >>> 17);\r\n      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\r\n\r\n      h1 ^= k1;\r\n          h1 = (h1 << 13) | (h1 >>> 19);\r\n      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\r\n      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\r\n    }\r\n\r\n    k1 = 0;\r\n\r\n    switch (remainder) {\r\n      case 3: k1 ^= (key[i + 2] & 0xff) << 16;\r\n      case 2: k1 ^= (key[i + 1] & 0xff) << 8;\r\n      case 1: k1 ^= (key[i] & 0xff);\r\n\r\n      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\r\n      k1 = (k1 << 15) | (k1 >>> 17);\r\n      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\r\n      h1 ^= k1;\r\n    }\r\n\r\n    h1 ^= key.length;\r\n\r\n    h1 ^= h1 >>> 16;\r\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\r\n    h1 ^= h1 >>> 13;\r\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\r\n    h1 ^= h1 >>> 16;\r\n\r\n    return h1 >>> 0;\r\n  }\r\n\r\n  var murmur = MurmurHashV3;\r\n  murmur.v2 = MurmurHashV2;\r\n  murmur.v3 = MurmurHashV3;\r\n\r\n  if (typeof(module) != 'undefined') {\r\n    module.exports = murmur;\r\n  } else {\r\n    var _previousRoot = _global.murmur;\r\n    murmur.noConflict = function() {\r\n      _global.murmur = _previousRoot;\r\n      return murmur;\r\n    }\r\n    _global.murmur = murmur;\r\n  }\r\n}());\r\n", "import EventEmitter from 'events';\nimport jwt_decode from 'jwt-decode';\nimport axios from 'axios';\nimport axiosRetry from 'axios-retry';\nimport { Claims, Options, StreamEvent, Target } from './types';\nimport { Configuration, ClientApi, FeatureConfig, Variation } from './openapi';\nimport { VERSION } from './version';\nimport { PollerEvent, PollingProcessor } from './polling';\nimport { StreamProcessor } from './streaming';\nimport { Evaluator } from './evaluator';\nimport { defaultOptions } from './constants';\nimport { Repository, RepositoryEvent, StorageRepository } from './repository';\nimport {\n  MetricEvent,\n  MetricsProcessor,\n  MetricsProcessorInterface,\n} from './metrics';\nimport { Logger } from './log';\n\naxios.defaults.timeout = 30000;\naxiosRetry(axios, { retries: 3, retryDelay: axiosRetry.exponentialDelay });\n\nenum Processor {\n  POLL,\n  STREAM,\n  METRICS,\n}\n\nexport enum Event {\n  READY = 'ready',\n  FAILED = 'failed',\n  CHANGED = 'changed',\n}\nexport default class Client {\n  private evaluator: Evaluator;\n  private repository: Repository;\n  private api: ClientApi;\n  private sdkKey: string;\n  private log: Logger;\n  private authToken: string;\n  private environment: string;\n  private configuration: Configuration;\n  private options: Options;\n  private cluster = '1';\n  private eventBus = new EventEmitter();\n  private pollProcessor: PollingProcessor;\n  private streamProcessor: StreamProcessor;\n  private metricsProcessor: MetricsProcessorInterface;\n  private initialized = false;\n  private failure = false;\n  private waitForInitialize: Promise<Client>;\n  private pollerReady = false;\n  private streamReady = false;\n  private metricReady = false;\n  private closing = false;\n\n  constructor(sdkKey: string, options: Options = {}) {\n    this.sdkKey = sdkKey;\n    this.options = { ...defaultOptions, ...options };\n    this.log = this.options.logger;\n\n    if (options.pollInterval < defaultOptions.pollInterval) {\n      this.options.pollInterval = defaultOptions.pollInterval;\n      this.log.warn(`Polling interval cannot be lower than ${defaultOptions.pollInterval} ms`);\n    }\n\n    if (options.eventsSyncInterval < defaultOptions.eventsSyncInterval) {\n      this.options.eventsSyncInterval = defaultOptions.eventsSyncInterval;\n      this.log.warn(`Events sync interval cannot be lower than ${defaultOptions.eventsSyncInterval} ms`);\n    }\n\n    this.configuration = new Configuration({\n      basePath: this.options.baseUrl,\n      baseOptions: {\n        headers: {\n          'User-Agent': `NodeJsSDK/${VERSION}`,\n        },\n      },\n    });\n\n    this.repository = new StorageRepository(\n      this.options.cache,\n      this.options.store,\n      this.eventBus,\n    );\n    this.evaluator = new Evaluator(this.repository, this.log);\n    this.api = new ClientApi(this.configuration);\n    this.processEvents();\n    this.run();\n  }\n\n  private processEvents(): void {\n    this.eventBus.on(PollerEvent.READY, () => {\n      this.initialize(Processor.POLL);\n    });\n\n    this.eventBus.on(PollerEvent.ERROR, () => {\n      this.failure = true;\n      this.eventBus.emit(Event.FAILED);\n    });\n\n    this.eventBus.on(StreamEvent.READY, () => {\n      this.initialize(Processor.STREAM);\n    });\n\n    this.eventBus.on(StreamEvent.RETRYING, () => {\n      this.failure = true;\n      this.log.error('Issue with streaming: falling back to polling while the SDK attempts to reconnect');\n      if (!this.closing) {\n        this.pollProcessor.start();\n      }\n    });\n\n    this.eventBus.on(StreamEvent.ERROR, () => {\n      this.failure = true;\n      this.log.error('Unrecoverable issue with streaming: falling back to polling');\n      if (!this.closing) {\n        this.pollProcessor.start();\n      }\n      this.eventBus.emit(Event.FAILED);\n    });\n\n    this.eventBus.on(MetricEvent.READY, () => {\n      this.initialize(Processor.METRICS);\n    });\n\n    this.eventBus.on(MetricEvent.ERROR, () => {\n      this.failure = true;\n      this.eventBus.emit(Event.FAILED);\n    });\n\n    this.eventBus.on(StreamEvent.CONNECTED, () => {\n      this.pollProcessor.stop();\n    });\n\n    this.eventBus.on(StreamEvent.DISCONNECTED, () => {\n      if (!this.closing) {\n        this.pollProcessor.start();\n      }\n    });\n\n    for (const event of Object.values(RepositoryEvent)) {\n      this.eventBus.on(event, (identifier) => {\n        switch (event) {\n          case RepositoryEvent.FLAG_STORED:\n          case RepositoryEvent.FLAG_DELETED:\n            this.eventBus.emit(Event.CHANGED, identifier);\n            break;\n          case RepositoryEvent.SEGMENT_STORED:\n          case RepositoryEvent.SEGMENT_DELETED:\n            // find all flags where segment match and emit the event\n            this.repository\n              .findFlagsBySegment(identifier)\n              .then((values: string[]) => {\n                values.forEach((value) =>\n                  this.eventBus.emit(Event.CHANGED, value),\n                );\n              });\n            break;\n        }\n      });\n    }\n  }\n\n  on(event: Event, callback: (...args: unknown[]) => void): void {\n    const arrayObjects = [];\n\n    for (const value of Object.values(Event)) {\n      arrayObjects.push(value);\n    }\n    if (arrayObjects.includes(event)) {\n      this.eventBus.on(event, callback);\n    }\n  }\n\n  off(event?: string, callback?: () => void): void {\n    if (event) {\n      this.eventBus.off(event, callback);\n    } else {\n      this.close();\n    }\n  }\n\n  private async authenticate(): Promise<void> {\n    try {\n      const response = await this.api.authenticate({\n        apiKey: this.sdkKey,\n      });\n      this.authToken = response.data.authToken;\n      this.configuration.accessToken = this.authToken;\n\n      const decoded: Claims = jwt_decode(this.authToken);\n\n      this.environment = decoded.environment;\n      this.cluster = decoded.clusterIdentifier || '1';\n    } catch (error) {\n      this.failure = true;\n      console.error('Error while authenticating, err: ', error);\n    }\n  }\n\n  waitForInitialization(): Promise<Client> {\n    if (this.waitForInitialize) {\n      return this.waitForInitialize;\n    }\n\n    if (this.initialized) {\n      this.waitForInitialize = Promise.resolve(this);\n    } else if (this.failure) {\n      this.waitForInitialize = Promise.reject(this.failure);\n    } else {\n      this.waitForInitialize = new Promise((resolve, reject) => {\n        this.eventBus.once(Event.READY, () => {\n          setTimeout(() => resolve(this), 0);\n        });\n        this.eventBus.once(Event.FAILED, reject);\n      });\n    }\n    return this.waitForInitialize;\n  }\n\n  private initialize(processor: Processor): void {\n    switch (processor) {\n      case Processor.POLL:\n        this.pollerReady = true;\n        this.log.debug('PollingProcessor ready');\n        break;\n      case Processor.STREAM:\n        this.streamReady = true;\n        this.log.debug('StreamingProcessor ready');\n        break;\n      case Processor.METRICS:\n        this.metricReady = true;\n        this.log.debug('MetricsProcessor ready');\n        break;\n    }\n\n    if (this.options.enableStream && !this.streamReady) {\n      return;\n    }\n\n    if (this.options.enableAnalytics && !this.metricReady) {\n      return;\n    }\n\n    if (!this.pollerReady) {\n      return;\n    }\n\n    this.initialized = true;\n    this.eventBus.emit(Event.READY);\n  }\n\n  private async run(): Promise<void> {\n    await this.authenticate();\n\n    this.pollProcessor = new PollingProcessor(\n      this.environment,\n      this.cluster,\n      this.api,\n      this.options,\n      this.eventBus,\n      this.repository,\n    );\n    this.pollProcessor.start();\n\n    if (this.options.enableStream) {\n      this.streamProcessor = new StreamProcessor(\n        this.api,\n        this.sdkKey,\n        this.environment,\n        this.authToken,\n        this.options,\n        this.cluster,\n        this.eventBus,\n        this.repository,\n      );\n\n      this.streamProcessor.start();\n    }\n\n    if (this.options.enableAnalytics) {\n      this.metricsProcessor = MetricsProcessor(\n        this.environment,\n        this.cluster,\n        this.configuration,\n        this.options,\n        this.eventBus,\n      );\n      this.metricsProcessor.start();\n    }\n\n    this.log.info('finished setting up processors');\n  }\n\n  boolVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = false,\n  ): Promise<boolean> {\n    return this.evaluator.boolVariation(\n      identifier,\n      target,\n      defaultValue,\n      (fc: FeatureConfig, target: Target, variation: Variation) => {\n        if (this.metricsProcessor) {\n          this.metricsProcessor.enqueue(target, fc, variation);\n        }\n      },\n    );\n  }\n\n  stringVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = '',\n  ): Promise<string> {\n    return this.evaluator.stringVariation(\n      identifier,\n      target,\n      defaultValue,\n      (fc: FeatureConfig, target: Target, variation: Variation) => {\n        if (this.metricsProcessor) {\n          this.metricsProcessor.enqueue(target, fc, variation);\n        }\n      },\n    );\n  }\n\n  numberVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = 0,\n  ): Promise<number> {\n    return this.evaluator.numberVariation(\n      identifier,\n      target,\n      defaultValue,\n      (fc: FeatureConfig, target: Target, variation: Variation) => {\n        if (this.metricsProcessor) {\n          this.metricsProcessor.enqueue(target, fc, variation);\n        }\n      },\n    );\n  }\n\n  jsonVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = {},\n  ): Promise<Record<string, unknown>> {\n    return this.evaluator.jsonVariation(\n      identifier,\n      target,\n      defaultValue,\n      (fc: FeatureConfig, target: Target, variation: Variation) => {\n        if (this.metricsProcessor) {\n          this.metricsProcessor.enqueue(target, fc, variation);\n        }\n      },\n    );\n  }\n\n  close(): void {\n    this.closing = true;\n    this.pollProcessor.close();\n    if (this.streamProcessor) {\n      this.streamProcessor.close();\n    }\n    if (this.metricsProcessor) {\n      this.metricsProcessor.close();\n    }\n    this.eventBus.removeAllListeners();\n    this.closing = false;\n  }\n}\n", "import { Logger } from './log';\nimport { FeatureConfig, Segment } from './openapi';\n\nexport type Type = boolean | string | number | Record<string, unknown>;\nexport interface Options {\n  baseUrl?: string;\n  eventsUrl?: string;\n  pollInterval?: number;\n  eventsSyncInterval?: number;\n  enableStream?: boolean;\n  enableAnalytics?: boolean;\n  cache?: KeyValueStore;\n  store?: AsyncKeyValueStore;\n  logger?: Logger;\n}\n\nexport interface Claims {\n  environment: string;\n  environmentIdentifier: string;\n  project: string;\n  projectIdentifier: string;\n  accountID: string;\n  organization: string;\n  organizationIdentifier: string;\n  clusterIdentifier: string;\n  key_type: 'Server';\n}\n\nexport interface StreamMsg {\n  event: string;\n  domain: string;\n  identifier: string;\n  version: number;\n}\n\nexport enum StreamEvent {\n  READY = 'stream_ready',\n  CONNECTED = 'stream_connected',\n  RETRYING = 'stream_retrying',\n  DISCONNECTED = 'stream_disconnected',\n  CHANGED = 'stream_changed',\n  ERROR = 'stream_error',\n}\n\nexport interface Operator {\n  startsWith(value: string[]): boolean;\n  endsWith(value: string[]): boolean;\n  match(value: string[]): boolean;\n  contains(value: string[]): boolean;\n  equalSensitive(value: string[]): boolean;\n  equal(value: string[]): boolean;\n  greaterThan(value: string[]): boolean;\n  greaterThanEqual(value: string[]): boolean;\n  lessThan(value: string[]): boolean;\n  lessThanEqual(value: string[]): boolean;\n  inList(value: string[]): boolean;\n}\n\nexport interface Query {\n  getFlag(identifier: string, cacheable?: boolean): Promise<FeatureConfig>;\n  getSegment(identifier: string, cacheable?: boolean): Promise<Segment>;\n  findFlagsBySegment(segment: string): Promise<string[]>;\n}\n\nexport interface KeyValueStore {\n  set(key: string, value: unknown): void;\n  get(key: string): unknown;\n  del(key: string): void;\n  keys(): string[];\n}\n\nexport interface AsyncKeyValueStore {\n  set(key: string, value: unknown): Promise<true>;\n  get<T>(key: string): Promise<T>;\n  del(key: string): Promise<boolean>;\n  keys(): Promise<string[]>;\n}\n\nexport interface Target {\n  identifier: string;\n  name: string;\n  anonymous?: boolean;\n  attributes?: Record<string, unknown>;\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/**\n * Harness feature flag service client apis\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.0.0\n * Contact: cf@harness.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from './configuration';\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';\n\n/**\n * \n * @export\n * @interface AuthenticationRequest\n */\nexport interface AuthenticationRequest {\n    /**\n     * \n     * @type {string}\n     * @memberof AuthenticationRequest\n     */\n    apiKey: string;\n    /**\n     * \n     * @type {AuthenticationRequestTarget}\n     * @memberof AuthenticationRequest\n     */\n    target?: AuthenticationRequestTarget;\n}\n/**\n * \n * @export\n * @interface AuthenticationRequestTarget\n */\nexport interface AuthenticationRequestTarget {\n    /**\n     * \n     * @type {string}\n     * @memberof AuthenticationRequestTarget\n     */\n    identifier: string;\n    /**\n     * \n     * @type {string}\n     * @memberof AuthenticationRequestTarget\n     */\n    name?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof AuthenticationRequestTarget\n     */\n    anonymous?: boolean;\n    /**\n     * \n     * @type {object}\n     * @memberof AuthenticationRequestTarget\n     */\n    attributes?: object;\n}\n/**\n * \n * @export\n * @interface AuthenticationResponse\n */\nexport interface AuthenticationResponse {\n    /**\n     * \n     * @type {string}\n     * @memberof AuthenticationResponse\n     */\n    authToken: string;\n}\n/**\n * \n * @export\n * @interface Clause\n */\nexport interface Clause {\n    /**\n     * \n     * @type {string}\n     * @memberof Clause\n     */\n    id: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Clause\n     */\n    attribute: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Clause\n     */\n    op: string;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof Clause\n     */\n    values: Array<string>;\n    /**\n     * \n     * @type {boolean}\n     * @memberof Clause\n     */\n    negate: boolean;\n}\n/**\n * \n * @export\n * @interface Distribution\n */\nexport interface Distribution {\n    /**\n     * \n     * @type {string}\n     * @memberof Distribution\n     */\n    bucketBy: string;\n    /**\n     * \n     * @type {Array<WeightedVariation>}\n     * @memberof Distribution\n     */\n    variations: Array<WeightedVariation>;\n}\n/**\n * \n * @export\n * @interface Evaluation\n */\nexport interface Evaluation {\n    /**\n     * \n     * @type {string}\n     * @memberof Evaluation\n     */\n    flag: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Evaluation\n     */\n    value: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Evaluation\n     */\n    kind: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Evaluation\n     */\n    identifier?: string;\n}\n/**\n * \n * @export\n * @interface FeatureConfig\n */\nexport interface FeatureConfig {\n    /**\n     * \n     * @type {string}\n     * @memberof FeatureConfig\n     */\n    project: string;\n    /**\n     * \n     * @type {string}\n     * @memberof FeatureConfig\n     */\n    environment: string;\n    /**\n     * \n     * @type {string}\n     * @memberof FeatureConfig\n     */\n    feature: string;\n    /**\n     * \n     * @type {FeatureState}\n     * @memberof FeatureConfig\n     */\n    state: FeatureState;\n    /**\n     * \n     * @type {string}\n     * @memberof FeatureConfig\n     */\n    kind: FeatureConfigKindEnum;\n    /**\n     * \n     * @type {Array<Variation>}\n     * @memberof FeatureConfig\n     */\n    variations: Array<Variation>;\n    /**\n     * \n     * @type {Array<ServingRule>}\n     * @memberof FeatureConfig\n     */\n    rules?: Array<ServingRule>;\n    /**\n     * \n     * @type {Serve}\n     * @memberof FeatureConfig\n     */\n    defaultServe: Serve;\n    /**\n     * \n     * @type {string}\n     * @memberof FeatureConfig\n     */\n    offVariation: string;\n    /**\n     * \n     * @type {Array<Prerequisite>}\n     * @memberof FeatureConfig\n     */\n    prerequisites?: Array<Prerequisite>;\n    /**\n     * \n     * @type {Array<VariationMap>}\n     * @memberof FeatureConfig\n     */\n    variationToTargetMap?: Array<VariationMap>;\n    /**\n     * \n     * @type {number}\n     * @memberof FeatureConfig\n     */\n    version?: number;\n}\n\n/**\n    * @export\n    * @enum {string}\n    */\nexport enum FeatureConfigKindEnum {\n    Boolean = 'boolean',\n    Int = 'int',\n    String = 'string',\n    Json = 'json'\n}\n\n/**\n * \n * @export\n * @enum {string}\n */\n\nexport enum FeatureState {\n    On = 'on',\n    Off = 'off'\n}\n\n/**\n * \n * @export\n * @interface KeyValue\n */\nexport interface KeyValue {\n    /**\n     * \n     * @type {string}\n     * @memberof KeyValue\n     */\n    key: string;\n    /**\n     * \n     * @type {string}\n     * @memberof KeyValue\n     */\n    value: string;\n}\n/**\n * \n * @export\n * @interface Metrics\n */\nexport interface Metrics {\n    /**\n     * \n     * @type {Array<TargetData>}\n     * @memberof Metrics\n     */\n    targetData?: Array<TargetData>;\n    /**\n     * \n     * @type {Array<MetricsData>}\n     * @memberof Metrics\n     */\n    metricsData?: Array<MetricsData>;\n}\n/**\n * \n * @export\n * @interface MetricsData\n */\nexport interface MetricsData {\n    /**\n     * time at when this data was recorded\n     * @type {number}\n     * @memberof MetricsData\n     */\n    timestamp: number;\n    /**\n     * \n     * @type {number}\n     * @memberof MetricsData\n     */\n    count: number;\n    /**\n     * This can be of type FeatureMetrics\n     * @type {string}\n     * @memberof MetricsData\n     */\n    metricsType: MetricsDataMetricsTypeEnum;\n    /**\n     * \n     * @type {Array<KeyValue>}\n     * @memberof MetricsData\n     */\n    attributes: Array<KeyValue>;\n}\n\n/**\n    * @export\n    * @enum {string}\n    */\nexport enum MetricsDataMetricsTypeEnum {\n    Ffmetrics = 'FFMETRICS'\n}\n\n/**\n * \n * @export\n * @interface ModelError\n */\nexport interface ModelError {\n    /**\n     * \n     * @type {string}\n     * @memberof ModelError\n     */\n    code: string;\n    /**\n     * \n     * @type {string}\n     * @memberof ModelError\n     */\n    message: string;\n}\n/**\n * \n * @export\n * @interface Pagination\n */\nexport interface Pagination {\n    /**\n     * \n     * @type {number}\n     * @memberof Pagination\n     */\n    version?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Pagination\n     */\n    pageCount: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Pagination\n     */\n    itemCount: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Pagination\n     */\n    pageSize: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Pagination\n     */\n    pageIndex: number;\n}\n/**\n * \n * @export\n * @interface Prerequisite\n */\nexport interface Prerequisite {\n    /**\n     * \n     * @type {string}\n     * @memberof Prerequisite\n     */\n    feature: string;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof Prerequisite\n     */\n    variations: Array<string>;\n}\n/**\n * \n * @export\n * @interface Segment\n */\nexport interface Segment {\n    /**\n     * Unique identifier for the segment.\n     * @type {string}\n     * @memberof Segment\n     */\n    identifier: string;\n    /**\n     * Name of the segment.\n     * @type {string}\n     * @memberof Segment\n     */\n    name: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Segment\n     */\n    environment?: string;\n    /**\n     * \n     * @type {Array<Tag>}\n     * @memberof Segment\n     */\n    tags?: Array<Tag>;\n    /**\n     * \n     * @type {Array<Target>}\n     * @memberof Segment\n     */\n    included?: Array<Target>;\n    /**\n     * \n     * @type {Array<Target>}\n     * @memberof Segment\n     */\n    excluded?: Array<Target>;\n    /**\n     * An array of rules that can cause a user to be included in this segment.\n     * @type {Array<Clause>}\n     * @memberof Segment\n     */\n    rules?: Array<Clause>;\n    /**\n     * \n     * @type {number}\n     * @memberof Segment\n     */\n    createdAt?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Segment\n     */\n    modifiedAt?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof Segment\n     */\n    version?: number;\n}\n/**\n * \n * @export\n * @interface Serve\n */\nexport interface Serve {\n    /**\n     * \n     * @type {Distribution}\n     * @memberof Serve\n     */\n    distribution?: Distribution;\n    /**\n     * \n     * @type {string}\n     * @memberof Serve\n     */\n    variation?: string;\n}\n/**\n * \n * @export\n * @interface ServingRule\n */\nexport interface ServingRule {\n    /**\n     * \n     * @type {string}\n     * @memberof ServingRule\n     */\n    ruleId: string;\n    /**\n     * \n     * @type {number}\n     * @memberof ServingRule\n     */\n    priority: number;\n    /**\n     * \n     * @type {Array<Clause>}\n     * @memberof ServingRule\n     */\n    clauses: Array<Clause>;\n    /**\n     * \n     * @type {Serve}\n     * @memberof ServingRule\n     */\n    serve: Serve;\n}\n/**\n * A name and value pair.\n * @export\n * @interface Tag\n */\nexport interface Tag {\n    /**\n     * \n     * @type {string}\n     * @memberof Tag\n     */\n    name: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Tag\n     */\n    value?: string;\n}\n/**\n * \n * @export\n * @interface Target\n */\nexport interface Target {\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    identifier: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    account: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    org: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    environment: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    project: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Target\n     */\n    name: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof Target\n     */\n    anonymous?: boolean;\n    /**\n     * \n     * @type {object}\n     * @memberof Target\n     */\n    attributes?: object;\n    /**\n     * \n     * @type {number}\n     * @memberof Target\n     */\n    createdAt?: number;\n    /**\n     * \n     * @type {Array<Segment>}\n     * @memberof Target\n     */\n    segments?: Array<Segment>;\n}\n/**\n * \n * @export\n * @interface TargetData\n */\nexport interface TargetData {\n    /**\n     * \n     * @type {string}\n     * @memberof TargetData\n     */\n    identifier: string;\n    /**\n     * \n     * @type {string}\n     * @memberof TargetData\n     */\n    name: string;\n    /**\n     * \n     * @type {Array<KeyValue>}\n     * @memberof TargetData\n     */\n    attributes: Array<KeyValue>;\n}\n/**\n * \n * @export\n * @interface TargetMap\n */\nexport interface TargetMap {\n    /**\n     * \n     * @type {string}\n     * @memberof TargetMap\n     */\n    identifier?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof TargetMap\n     */\n    name: string;\n}\n/**\n * \n * @export\n * @interface Variation\n */\nexport interface Variation {\n    /**\n     * \n     * @type {string}\n     * @memberof Variation\n     */\n    identifier: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Variation\n     */\n    value: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Variation\n     */\n    name?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Variation\n     */\n    description?: string;\n}\n/**\n * \n * @export\n * @interface VariationMap\n */\nexport interface VariationMap {\n    /**\n     * \n     * @type {string}\n     * @memberof VariationMap\n     */\n    variation: string;\n    /**\n     * \n     * @type {Array<TargetMap>}\n     * @memberof VariationMap\n     */\n    targets?: Array<TargetMap>;\n    /**\n     * \n     * @type {Array<string>}\n     * @memberof VariationMap\n     */\n    targetSegments?: Array<string>;\n}\n/**\n * \n * @export\n * @interface WeightedVariation\n */\nexport interface WeightedVariation {\n    /**\n     * \n     * @type {string}\n     * @memberof WeightedVariation\n     */\n    variation: string;\n    /**\n     * \n     * @type {number}\n     * @memberof WeightedVariation\n     */\n    weight: number;\n}\n\n/**\n * ClientApi - axios parameter creator\n * @export\n */\nexport const ClientApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Used to retrieve all target segments for certain account id.\n         * @summary Authenticate with the admin server.\n         * @param {AuthenticationRequest} [authenticationRequest] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authenticate: async (authenticationRequest?: AuthenticationRequest, options: any = {}): Promise<RequestArgs> => {\n            const localVarPath = `/client/auth`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Used to retrieve all segments for certain account id.\n         * @summary Retrieve all segments.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllSegments: async (environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getAllSegments', 'environmentUUID', environmentUUID)\n            const localVarPath = `/client/env/{environmentUUID}/target-segments`\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} feature Unique identifier for the flag object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEvaluationByIdentifier: async (environmentUUID: string, feature: string, target: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getEvaluationByIdentifier', 'environmentUUID', environmentUUID)\n            // verify required parameter 'feature' is not null or undefined\n            assertParamExists('getEvaluationByIdentifier', 'feature', feature)\n            // verify required parameter 'target' is not null or undefined\n            assertParamExists('getEvaluationByIdentifier', 'target', target)\n            const localVarPath = `/client/env/{environmentUUID}/target/{target}/evaluations/{feature}`\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)))\n                .replace(`{${\"feature\"}}`, encodeURIComponent(String(feature)))\n                .replace(`{${\"target\"}}`, encodeURIComponent(String(target)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEvaluations: async (environmentUUID: string, target: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getEvaluations', 'environmentUUID', environmentUUID)\n            // verify required parameter 'target' is not null or undefined\n            assertParamExists('getEvaluations', 'target', target)\n            const localVarPath = `/client/env/{environmentUUID}/target/{target}/evaluations`\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)))\n                .replace(`{${\"target\"}}`, encodeURIComponent(String(target)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * All feature flags with activations in project environment\n         * @summary Get all feature flags activations\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFeatureConfig: async (environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getFeatureConfig', 'environmentUUID', environmentUUID)\n            const localVarPath = `/client/env/{environmentUUID}/feature-configs`\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get feature config\n         * @param {string} identifier Unique identifier for the flag object in the API.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFeatureConfigByIdentifier: async (identifier: string, environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'identifier' is not null or undefined\n            assertParamExists('getFeatureConfigByIdentifier', 'identifier', identifier)\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getFeatureConfigByIdentifier', 'environmentUUID', environmentUUID)\n            const localVarPath = `/client/env/{environmentUUID}/feature-configs/{identifier}`\n                .replace(`{${\"identifier\"}}`, encodeURIComponent(String(identifier)))\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Used to retrieve a segment for a certain account id by identifier\n         * @summary Retrieve a segment by identifier\n         * @param {string} identifier Unique identifier for the segment object in the API\n         * @param {string} environmentUUID Unique identifier for the environment object in the API\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSegmentByIdentifier: async (identifier: string, environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'identifier' is not null or undefined\n            assertParamExists('getSegmentByIdentifier', 'identifier', identifier)\n            // verify required parameter 'environmentUUID' is not null or undefined\n            assertParamExists('getSegmentByIdentifier', 'environmentUUID', environmentUUID)\n            const localVarPath = `/client/env/{environmentUUID}/target-segments/{identifier}`\n                .replace(`{${\"identifier\"}}`, encodeURIComponent(String(identifier)))\n                .replace(`{${\"environmentUUID\"}}`, encodeURIComponent(String(environmentUUID)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Stream endpoint.\n         * @param {string} aPIKey \n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        stream: async (aPIKey: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'aPIKey' is not null or undefined\n            assertParamExists('stream', 'aPIKey', aPIKey)\n            const localVarPath = `/stream`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n            if (aPIKey !== undefined && aPIKey !== null) {\n                localVarHeaderParameter['API-Key'] = String(aPIKey);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * ClientApi - functional programming interface\n * @export\n */\nexport const ClientApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Used to retrieve all target segments for certain account id.\n         * @summary Authenticate with the admin server.\n         * @param {AuthenticationRequest} [authenticationRequest] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async authenticate(authenticationRequest?: AuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticationRequest, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * Used to retrieve all segments for certain account id.\n         * @summary Retrieve all segments.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAllSegments(environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSegments(environmentUUID, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} feature Unique identifier for the flag object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluation>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pagination & object>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluations(environmentUUID, target, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * All feature flags with activations in project environment\n         * @summary Get all feature flags activations\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFeatureConfig(environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureConfig>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureConfig(environmentUUID, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Get feature config\n         * @param {string} identifier Unique identifier for the flag object in the API.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureConfig>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * Used to retrieve a segment for a certain account id by identifier\n         * @summary Retrieve a segment by identifier\n         * @param {string} identifier Unique identifier for the segment object in the API\n         * @param {string} environmentUUID Unique identifier for the environment object in the API\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentByIdentifier(identifier, environmentUUID, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n        /**\n         * \n         * @summary Stream endpoint.\n         * @param {string} aPIKey \n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async stream(aPIKey: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.stream(aPIKey, cluster, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * ClientApi - factory interface\n * @export\n */\nexport const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = ClientApiFp(configuration)\n    return {\n        /**\n         * Used to retrieve all target segments for certain account id.\n         * @summary Authenticate with the admin server.\n         * @param {AuthenticationRequest} [authenticationRequest] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        authenticate(authenticationRequest?: AuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse> {\n            return localVarFp.authenticate(authenticationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Used to retrieve all segments for certain account id.\n         * @summary Retrieve all segments.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAllSegments(environmentUUID: string, cluster?: string, options?: any): AxiosPromise<Array<Segment>> {\n            return localVarFp.getAllSegments(environmentUUID, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} feature Unique identifier for the flag object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any): AxiosPromise<Evaluation> {\n            return localVarFp.getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get feature evaluations for target\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} target Unique identifier for the target object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any): AxiosPromise<Pagination & object> {\n            return localVarFp.getEvaluations(environmentUUID, target, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * All feature flags with activations in project environment\n         * @summary Get all feature flags activations\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFeatureConfig(environmentUUID: string, cluster?: string, options?: any): AxiosPromise<Array<FeatureConfig>> {\n            return localVarFp.getFeatureConfig(environmentUUID, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get feature config\n         * @param {string} identifier Unique identifier for the flag object in the API.\n         * @param {string} environmentUUID Unique identifier for the environment object in the API.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): AxiosPromise<FeatureConfig> {\n            return localVarFp.getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Used to retrieve a segment for a certain account id by identifier\n         * @summary Retrieve a segment by identifier\n         * @param {string} identifier Unique identifier for the segment object in the API\n         * @param {string} environmentUUID Unique identifier for the environment object in the API\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): AxiosPromise<Segment> {\n            return localVarFp.getSegmentByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Stream endpoint.\n         * @param {string} aPIKey \n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        stream(aPIKey: string, cluster?: string, options?: any): AxiosPromise<void> {\n            return localVarFp.stream(aPIKey, cluster, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * ClientApi - object-oriented interface\n * @export\n * @class ClientApi\n * @extends {BaseAPI}\n */\nexport class ClientApi extends BaseAPI {\n    /**\n     * Used to retrieve all target segments for certain account id.\n     * @summary Authenticate with the admin server.\n     * @param {AuthenticationRequest} [authenticationRequest] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public authenticate(authenticationRequest?: AuthenticationRequest, options?: any) {\n        return ClientApiFp(this.configuration).authenticate(authenticationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Used to retrieve all segments for certain account id.\n     * @summary Retrieve all segments.\n     * @param {string} environmentUUID Unique identifier for the environment object in the API.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getAllSegments(environmentUUID: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getAllSegments(environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get feature evaluations for target\n     * @param {string} environmentUUID Unique identifier for the environment object in the API.\n     * @param {string} feature Unique identifier for the flag object in the API.\n     * @param {string} target Unique identifier for the target object in the API.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get feature evaluations for target\n     * @param {string} environmentUUID Unique identifier for the environment object in the API.\n     * @param {string} target Unique identifier for the target object in the API.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getEvaluations(environmentUUID, target, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * All feature flags with activations in project environment\n     * @summary Get all feature flags activations\n     * @param {string} environmentUUID Unique identifier for the environment object in the API.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getFeatureConfig(environmentUUID: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getFeatureConfig(environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get feature config\n     * @param {string} identifier Unique identifier for the flag object in the API.\n     * @param {string} environmentUUID Unique identifier for the environment object in the API.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Used to retrieve a segment for a certain account id by identifier\n     * @summary Retrieve a segment by identifier\n     * @param {string} identifier Unique identifier for the segment object in the API\n     * @param {string} environmentUUID Unique identifier for the environment object in the API\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).getSegmentByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Stream endpoint.\n     * @param {string} aPIKey \n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ClientApi\n     */\n    public stream(aPIKey: string, cluster?: string, options?: any) {\n        return ClientApiFp(this.configuration).stream(aPIKey, cluster, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n/**\n * MetricsApi - axios parameter creator\n * @export\n */\nexport const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Send metrics to Analytics server\n         * @summary Send metrics to the Analytics server.\n         * @param {string} environment environment parameter in query.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {Metrics} [metrics] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        postMetrics: async (environment: string, cluster?: string, metrics?: Metrics, options: any = {}): Promise<RequestArgs> => {\n            // verify required parameter 'environment' is not null or undefined\n            assertParamExists('postMetrics', 'environment', environment)\n            const localVarPath = `/metrics/{environment}`\n                .replace(`{${\"environment\"}}`, encodeURIComponent(String(environment)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (cluster !== undefined) {\n                localVarQueryParameter['cluster'] = cluster;\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(metrics, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * MetricsApi - functional programming interface\n * @export\n */\nexport const MetricsApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Send metrics to Analytics server\n         * @summary Send metrics to the Analytics server.\n         * @param {string} environment environment parameter in query.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {Metrics} [metrics] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async postMetrics(environment: string, cluster?: string, metrics?: Metrics, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetrics(environment, cluster, metrics, options);\n            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);\n        },\n    }\n};\n\n/**\n * MetricsApi - factory interface\n * @export\n */\nexport const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = MetricsApiFp(configuration)\n    return {\n        /**\n         * Send metrics to Analytics server\n         * @summary Send metrics to the Analytics server.\n         * @param {string} environment environment parameter in query.\n         * @param {string} [cluster] Unique identifier for the cluster for the account\n         * @param {Metrics} [metrics] \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        postMetrics(environment: string, cluster?: string, metrics?: Metrics, options?: any): AxiosPromise<void> {\n            return localVarFp.postMetrics(environment, cluster, metrics, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * MetricsApi - object-oriented interface\n * @export\n * @class MetricsApi\n * @extends {BaseAPI}\n */\nexport class MetricsApi extends BaseAPI {\n    /**\n     * Send metrics to Analytics server\n     * @summary Send metrics to the Analytics server.\n     * @param {string} environment environment parameter in query.\n     * @param {string} [cluster] Unique identifier for the cluster for the account\n     * @param {Metrics} [metrics] \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MetricsApi\n     */\n    public postMetrics(environment: string, cluster?: string, metrics?: Metrics, options?: any) {\n        return MetricsApiFp(this.configuration).postMetrics(environment, cluster, metrics, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n\n", "/* tslint:disable */\n/* eslint-disable */\n/**\n * Harness feature flag service client apis\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.0.0\n * Contact: cf@harness.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from \"./configuration\";\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport globalAxios, { AxiosPromise, AxiosInstance } from 'axios';\n\nexport const BASE_PATH = \"http://localhost/api/1.0\".replace(/\\/+$/, \"\");\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\n/**\n *\n * @export\n * @interface RequestArgs\n */\nexport interface RequestArgs {\n    url: string;\n    options: any;\n}\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPI {\n    protected configuration: Configuration | undefined;\n\n    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath || this.basePath;\n        }\n    }\n};\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n    name: \"RequiredError\" = \"RequiredError\";\n    constructor(public field: string, msg?: string) {\n        super(msg);\n    }\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/**\n * Harness feature flag service client apis\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.0.0\n * Contact: cf@harness.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport { Configuration } from \"./configuration\";\nimport { RequiredError,\u3000RequestArgs } from \"./base\";\nimport { AxiosInstance } from 'axios';\n\n/**\n *\n * @export\n */\nexport const DUMMY_BASE_URL = 'https://example.com'\n\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nexport const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setApiKeyToObject = async function (object: any, keyParamName: string, configuration?: Configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBasicAuthToObject = function (object: any, configuration?: Configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBearerAuthToObject = async function (object: any, configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setOAuthToObject = async function (object: any, name: string, scopes: string[], configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setSearchParams = function (url: URL, ...objects: any[]) {\n    const searchParams = new URLSearchParams(url.search);\n    for (const object of objects) {\n        for (const key in object) {\n            if (Array.isArray(object[key])) {\n                searchParams.delete(key);\n                for (const item of object[key]) {\n                    searchParams.append(key, item);\n                }\n            } else {\n                searchParams.set(key, object[key]);\n            }\n        }\n    }\n    url.search = searchParams.toString();\n}\n\n/**\n *\n * @export\n */\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n}\n\n/**\n *\n * @export\n */\nexport const toPathString = function (url: URL) {\n    return url.pathname + url.search + url.hash\n}\n\n/**\n *\n * @export\n */\nexport const createRequestFunction = function (axiosArgs: RequestArgs, globalAxios: AxiosInstance, BASE_PATH: string, configuration?: Configuration) {\n    return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {\n        const axiosRequestArgs = {...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url};\n        return axios.request(axiosRequestArgs);\n    };\n}\n", "/* tslint:disable */\n/* eslint-disable */\n/**\n * Harness feature flag service client apis\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.0.0\n * Contact: cf@harness.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ConfigurationParameters {\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    username?: string;\n    password?: string;\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    basePath?: string;\n    baseOptions?: any;\n    formDataCtor?: new () => any;\n}\n\nexport class Configuration {\n    /**\n     * parameter for apiKey security\n     * @param name security name\n     * @memberof Configuration\n     */\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    username?: string;\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    password?: string;\n    /**\n     * parameter for oauth2 security\n     * @param name security name\n     * @param scopes oauth2 scope\n     * @memberof Configuration\n     */\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    /**\n     * override base path\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    basePath?: string;\n    /**\n     * base options for axios calls\n     *\n     * @type {any}\n     * @memberof Configuration\n     */\n    baseOptions?: any;\n    /**\n     * The FormData constructor that will be used to create multipart form data\n     * requests. You can inject this here so that execution environments that\n     * do not support the FormData class can still run the generated client.\n     *\n     * @type {new () => FormData}\n     */\n    formDataCtor?: new () => any;\n\n    constructor(param: ConfigurationParameters = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n", "export const VERSION = \"1.2.15\";\n", "import { ClientApi, FeatureConfig, Segment } from './openapi';\nimport { Options } from './types';\nimport EventEmitter from 'events';\nimport { Repository } from './repository';\nimport { ConsoleLog } from './log';\n\nexport enum PollerEvent {\n  READY = 'poller_ready',\n  ERROR = 'poller_error',\n}\n\nexport class PollingProcessor {\n  private environment: string;\n  private cluster: string;\n  private api: ClientApi;\n  private stopped = true;\n  private options: Options;\n  private repository: Repository;\n  private initialized = false;\n  private eventBus: EventEmitter;\n  private timeout: NodeJS.Timeout;\n  private log: ConsoleLog;\n\n  constructor(\n    environment: string,\n    cluster: string,\n    api: ClientApi,\n    options: Options,\n    eventBus: EventEmitter,\n    repository: Repository,\n  ) {\n    this.api = api;\n    this.options = options;\n    this.environment = environment;\n    this.cluster = cluster;\n    this.repository = repository;\n    this.eventBus = eventBus;\n    this.log = options.logger;\n  }\n\n  private poll() {\n    if (this.stopped) {\n      this.log.info('PollingProcessor stopped');\n      return;\n    }\n\n    const startTime = new Date().getTime();\n    const pollAgain = () => {\n      const elapsed = new Date().getTime() - startTime;\n      const sleepFor = Math.max(this.options.pollInterval - elapsed, 0);\n\n      this.timeout = setTimeout(() => this.poll(), sleepFor);\n    };\n\n    Promise.all([this.retrieveFlags(), this.retrieveSegments()])\n      .then(() => {\n        // when first fetch is successful then poller is ready\n        if (!this.initialized) {\n          this.initialized = true;\n          this.eventBus.emit(PollerEvent.READY);\n        }\n      })\n      .catch((error) => {\n        this.eventBus.emit(PollerEvent.ERROR, { error });\n      })\n      .finally(() => {\n        // we will check one more time if processor is stopped\n        if (this.stopped) {\n          this.log.info('PollingProcessor stopped');\n          return;\n        }\n        pollAgain();\n      });\n  }\n\n  private async retrieveFlags(): Promise<void> {\n    try {\n      this.log.debug('Fetching flags started');\n      const response = await this.api.getFeatureConfig(\n        this.environment,\n        this.cluster,\n      );\n      this.log.debug('Fetching flags finished');\n      response.data.forEach((fc: FeatureConfig) =>\n        this.repository.setFlag(fc.feature, fc),\n      );\n    } catch (error) {\n      this.log.error('Error loading flags', error);\n      throw error;\n    }\n  }\n\n  private async retrieveSegments(): Promise<void> {\n    try {\n      this.log.debug('Fetching segments started');\n      const response = await this.api.getAllSegments(\n        this.environment,\n        this.cluster,\n      );\n      this.log.debug('Fetching segments finished');\n      // prepare cache for storing segments\n      response.data.forEach((segment: Segment) =>\n        this.repository.setSegment(segment.identifier, segment),\n      );\n    } catch (error) {\n      this.log.error('Error loading segments', error);\n      throw error;\n    }\n  }\n\n  start(): void {\n    if (!this.stopped) {\n      this.log.info('PollingProcessor already started');\n      return;\n    }\n    this.log.info(\n      'Starting PollingProcessor with request interval: ',\n      this.options.pollInterval,\n    );\n    this.stopped = false;\n    this.poll();\n  }\n\n  stop(): void {\n    this.log.info('Stopping PollingProcessor');\n    this.stopped = true;\n  }\n\n  close(): void {\n    this.log.info('Closing PollingProcessor');\n    this.stop();\n    clearTimeout(this.timeout);\n    this.log.info('PollingProcessor closed');\n  }\n}\n", "import EventSource from '@harnessio/eventsource'\nimport EventEmitter from 'events';\nimport { AxiosPromise } from 'axios';\nimport { ClientApi, FeatureConfig, Segment } from './openapi';\nimport { StreamEvent, Options, StreamMsg } from './types';\nimport { Repository } from './repository';\nimport { ConsoleLog } from './log';\n\ntype FetchFunction = (\n  identifier: string,\n  environment: string,\n  cluster: string,\n) => AxiosPromise<FeatureConfig | Segment>;\n\nexport class StreamProcessor {\n  static readonly CONNECTED = 1;\n\n  private apiKey: string;\n  private jwtToken: string;\n  private environment: string;\n  private options: Options;\n  private cluster: string;\n  private eventBus: EventEmitter;\n  private api: ClientApi;\n  private eventSource: EventSource;\n  private repository: Repository;\n  private log: ConsoleLog;\n  private isRetrying: boolean\n\n  constructor(\n    api: ClientApi,\n    apiKey: string,\n    environment: string,\n    jwtToken: string,\n    options: Options,\n    cluster: string,\n    eventBus: EventEmitter,\n    repository: Repository,\n  ) {\n    this.api = api;\n    this.apiKey = apiKey;\n    this.environment = environment;\n    this.jwtToken = jwtToken;\n    this.options = options;\n    this.cluster = cluster;\n    this.eventBus = eventBus;\n    this.repository = repository;\n    this.log = this.options.logger;\n  }\n\n  start(): void {\n    this.log.info('Starting StreamProcessor');\n    const eventSource = new EventSource(\n      `${this.options.baseUrl}/stream?cluster=${this.cluster}`,\n      {\n        headers: {\n          Authorization: `Bearer ${this.jwtToken}`,\n          'API-Key': this.apiKey,\n        },\n      },\n    );\n\n    eventSource.onopen = (event: MessageEvent) => {\n      this.log.debug('Stream connected', event);\n      this.eventBus.emit(StreamEvent.CONNECTED);\n      // In case we've had to retry, set it back to false\n      this.isRetrying = false\n    };\n\n    eventSource.onretrying = (event: MessageEvent) => {\n      this.log.error('Stream is trying to reconnect', event);\n      // Only inform the client once that we're retrying\n      if (!this.isRetrying) {\n        this.isRetrying = true\n        this.eventBus.emit(StreamEvent.RETRYING);\n      }\n    };\n\n    eventSource.onerror = (event: MessageEvent) => {\n      this.log.error('Unrecoverable error with stream, not retrying to connect: ', event);\n      this.eventBus.emit(StreamEvent.ERROR, event);\n    };\n\n    eventSource.addEventListener('*', (event: MessageEvent) => {\n      const msg: StreamMsg = JSON.parse(event.data);\n\n      this.log.debug('Received event from stream: ', msg);\n\n      if (msg.domain === 'flag') {\n        this.msgProcessor(\n          msg,\n          this.api.getFeatureConfigByIdentifier.bind(this.api),\n          this.repository.setFlag.bind(this.repository),\n          this.repository.deleteFlag.bind(this.repository),\n        );\n      } else if (msg.domain === 'target-segment') {\n        this.msgProcessor(\n          msg,\n          this.api.getSegmentByIdentifier.bind(this.api),\n          this.repository.setSegment.bind(this.repository),\n          this.repository.deleteSegment.bind(this.repository),\n        );\n      }\n    });\n\n    this.eventSource = eventSource;\n    this.eventBus.emit(StreamEvent.READY);\n  }\n\n  private async msgProcessor(\n    msg: StreamMsg,\n    fn: FetchFunction,\n    setFn: (identifier: string, data: FeatureConfig | Segment) => void,\n    delFn: (identifier: string) => void,\n  ): Promise<void> {\n    this.log.info('Processing message', msg);\n    try {\n      if (msg.event === 'create' || msg.event === 'patch') {\n        const { data } = await fn(\n          msg.identifier,\n          this.environment,\n          this.cluster,\n        );\n        setFn(msg.identifier, data);\n      } else if (msg.event === 'delete') {\n        delFn(msg.identifier);\n      }\n    } catch (error) {\n      this.log.error(\n        'Error while fetching data with identifier:',\n        msg.identifier,\n        error,\n      );\n      throw error;\n    }\n    this.log.info('Processing message finished', msg);\n    return;\n  }\n\n  connected(): boolean {\n    return this.eventSource.readyState == StreamProcessor.CONNECTED;\n  }\n\n  stop(): void {\n    this.log.info('Stopping StreamProcessor');\n    this.eventSource.close();\n    this.eventBus.emit(StreamEvent.DISCONNECTED);\n  }\n\n  close(): void {\n    this.log.info('Closing StreamProcessor');\n    this.stop();\n    this.log.info('StreamProcessor closed');\n  }\n}\n", "import LRU from 'lru-cache';\nimport { ConsoleLog } from './log';\nimport { FileStore } from './store';\nimport { Options } from './types';\n\nexport const ONE_HUNDRED = 100;\n\nexport const FF_METRIC_TYPE = 'FFMETRICS',\n  FEATURE_IDENTIFIER_ATTRIBUTE = 'featureIdentifier',\n  FEATURE_NAME_ATTRIBUTE = 'featureName',\n  VARIATION_IDENTIFIER_ATTRIBUTE = 'variationIdentifier',\n  VARIATION_VALUE_ATTRIBUTE = 'featureValue',\n  TARGET_ATTRIBUTE = 'target',\n  SDK_VERSION_ATTRIBUTE = 'SDK_VERSION',\n  SDK_TYPE_ATTRIBUTE = 'SDK_TYPE',\n  SDK_TYPE = 'server',\n  SDK_LANGUAGE_ATTRIBUTE = 'SDK_LANGUAGE',\n  SDK_LANGUAGE = 'javascript',\n  GLOBAL_TARGET = 'global';\n\nexport const SEGMENT_MATCH_OPERATOR = 'segmentMatch',\n  IN_OPERATOR = 'in',\n  EQUAL_OPERATOR = 'equal',\n  GT_OPERATOR = 'gt',\n  STARTS_WITH_OPERATOR = 'starts_with',\n  ENDS_WITH_OPERATOR = 'ends_with',\n  CONTAINS_OPERATOR = 'contains',\n  EQUAL_SENSITIVE_OPERATOR = 'equal_sensitive';\n\nexport const BASE_URL = 'https://config.ff.harness.io/api/1.0',\n  EVENTS_URL = 'https://events.ff.harness.io/api/1.0',\n  SECOND = 1000,\n  MINUTE = 60 * SECOND,\n  PULL_INTERVAL = 1 * MINUTE,\n  EVENTS_SYNC_INTERVAL = 1 * MINUTE;\n\nexport const defaultOptions: Options = {\n  baseUrl: BASE_URL,\n  eventsUrl: EVENTS_URL,\n  pollInterval: PULL_INTERVAL,\n  eventsSyncInterval: EVENTS_SYNC_INTERVAL,\n  enableStream: true,\n  enableAnalytics: true,\n  cache: new LRU({ max: 100 }),\n  store: new FileStore(),\n  logger: new ConsoleLog(),\n};\n", "export interface Logger {\n  trace(message?: unknown, ...optionalParams: unknown[]): void;\n  debug(message?: unknown, ...optionalParams: unknown[]): void;\n  info(message?: unknown, ...optionalParams: unknown[]): void;\n  warn(message?: unknown, ...optionalParams: unknown[]): void;\n  error(message?: unknown, ...optionalParams: unknown[]): void;\n}\n\n// Wrapper for console\nexport class ConsoleLog implements Logger {\n  trace(message?: unknown, ...optionalParams: unknown[]): void {\n    console.trace(message, ...optionalParams);\n  }\n  debug(message?: unknown, ...optionalParams: unknown[]): void {\n    console.debug(message, ...optionalParams);\n  }\n  info(message?: unknown, ...optionalParams: unknown[]): void {\n    console.info(message, ...optionalParams);\n  }\n  warn(message?: unknown, ...optionalParams: unknown[]): void {\n    console.warn(message, ...optionalParams);\n  }\n  error(message?: unknown, ...optionalParams: unknown[]): void {\n    console.error(message, ...optionalParams);\n  }\n}\n", "import Keyv from 'keyv';\nimport { KeyvFile } from 'keyv-file';\nimport { AsyncKeyValueStore } from './types';\n\nexport class FileStore implements AsyncKeyValueStore {\n  private keyv: Keyv;\n  private keyvFile: KeyvFile;\n\n  constructor(options = {}) {\n    this.keyvFile = new KeyvFile(options);\n    this.keyv = new Keyv({\n      store: this.keyvFile,\n    });\n  }\n\n  set(key: string, value: unknown): Promise<true> {\n    return this.keyv.set(key, value);\n  }\n\n  get<T>(key: string): Promise<T> {\n    return this.keyv.get(key);\n  }\n\n  del(key: string): Promise<boolean> {\n    return this.keyv.delete(key);\n  }\n\n  keys(): Promise<string[]> {\n    return Promise.resolve(this.keyvFile.keys());\n  }\n}\n", "import {\n  CONTAINS_OPERATOR,\n  ENDS_WITH_OPERATOR,\n  EQUAL_OPERATOR,\n  EQUAL_SENSITIVE_OPERATOR,\n  GT_OPERATOR,\n  IN_OPERATOR,\n  ONE_HUNDRED,\n  SEGMENT_MATCH_OPERATOR,\n  STARTS_WITH_OPERATOR,\n} from './constants';\nimport { Query, Target, Type } from './types';\nimport {\n  Clause,\n  Distribution,\n  FeatureConfig,\n  FeatureConfigKindEnum,\n  FeatureState,\n  ServingRule,\n  Variation,\n  Target as ApiTarget,\n  VariationMap,\n} from './openapi';\nimport murmurhash from 'murmurhash';\nimport { ConsoleLog } from './log';\n\ntype Callback = (\n  fc: FeatureConfig,\n  target: Target,\n  variation: Variation,\n) => void;\n\nexport class Evaluator {\n  private query: Query;\n  private log: ConsoleLog;\n\n  constructor(query: Query, logger: ConsoleLog) {\n    this.query = query;\n    this.log = logger;\n  }\n\n  private getAttrValue(target: Target, attribute: string): Type | undefined {\n    return target[attribute] || target.attributes?.[attribute];\n  }\n\n  private findVariation(\n    variations: Variation[],\n    identifier: string,\n  ): Variation | undefined {\n    return variations.find(\n      (value: Variation) => value.identifier === identifier,\n    );\n  }\n\n  private getNormalizedNumberWithNormalizer(\n    property: Type,\n    bucketBy: string,\n    normalizer: number,\n  ): number {\n    const value = [bucketBy, property].join(':');\n    const hash = parseInt(murmurhash(value).toString());\n    return (hash % normalizer) + 1;\n  }\n\n  private getNormalizedNumber(property: Type, bucketBy: string): number {\n    return this.getNormalizedNumberWithNormalizer(\n      property,\n      bucketBy,\n      ONE_HUNDRED,\n    );\n  }\n\n  private isEnabled(\n    target: Target,\n    bucketBy: string,\n    percentage: number,\n  ): boolean {\n    const property = this.getAttrValue(target, bucketBy);\n    if (!property) {\n      return false;\n    }\n    const bucketId = this.getNormalizedNumber(property, bucketBy);\n    return percentage > 0 && bucketId <= percentage;\n  }\n\n  private evaluateDistribution(\n    distribution: Distribution,\n    target: Target,\n  ): string {\n    if (!distribution) {\n      return undefined;\n    }\n\n    let variation = '';\n    let totalPercentage = 0;\n    for (const v of distribution.variations) {\n      variation = v.variation;\n      totalPercentage += v.weight;\n      if (this.isEnabled(target, distribution.bucketBy, totalPercentage)) {\n        return v.variation;\n      }\n    }\n    return variation;\n  }\n\n  private async isTargetIncludedOrExcludedInSegment(\n    segments: string[],\n    target: Target,\n  ): Promise<boolean> {\n    for (const segmentIdentifier of segments) {\n      const segment = await this.query.getSegment(segmentIdentifier);\n\n      if (segment) {\n        // Should Target be excluded - if in excluded list we return false\n        if (\n          segment.excluded?.find(\n            (value: ApiTarget) => value.identifier === target.identifier,\n          )\n        ) {\n          this.log.debug(\n            'Target %s excluded from segment %s via exclude list\\n',\n            target.name,\n            segment.name,\n          );\n          return false;\n        }\n\n        // Should Target be included - if in included list we return true\n        if (\n          segment.included?.find(\n            (value: ApiTarget) => value.identifier === target.identifier,\n          )\n        ) {\n          this.log.debug(\n            'Target %s included in segment %s via include list\\n',\n            target.name,\n            segment.name,\n          );\n          return true;\n        }\n\n        // Should Target be included via segment rules\n        if (\n          segment.rules &&\n          (await this.evaluateClauses(segment.rules, target))\n        ) {\n          this.log.debug(\n            'Target %s included in segment %s via rules\\n',\n            target.name,\n            segment.name,\n          );\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private async evaluateClause(\n    clause: Clause,\n    target: Target,\n  ): Promise<boolean> {\n    if (!clause?.op || !clause?.values?.length) {\n      return false;\n    }\n\n    const attrValue = this.getAttrValue(target, clause.attribute);\n    const targetAttribute = attrValue?.toString();\n    if (clause.op !== SEGMENT_MATCH_OPERATOR && !targetAttribute) {\n      return false;\n    }\n\n    const value = clause.values[0];\n\n    switch (clause.op) {\n      case IN_OPERATOR:\n        for (const val of clause.values) {\n          if (val == targetAttribute) {\n            return true;\n          }\n        }\n        return false;\n      case EQUAL_OPERATOR:\n        return targetAttribute.toLowerCase() == value.toLowerCase();\n      case EQUAL_SENSITIVE_OPERATOR:\n        return targetAttribute == value;\n      case GT_OPERATOR:\n        return targetAttribute > value;\n      case STARTS_WITH_OPERATOR:\n        return targetAttribute.startsWith(value);\n      case ENDS_WITH_OPERATOR:\n        return targetAttribute.endsWith(value);\n      case CONTAINS_OPERATOR:\n        return targetAttribute.includes(value);\n      case SEGMENT_MATCH_OPERATOR:\n        return await this.isTargetIncludedOrExcludedInSegment(\n          clause.values,\n          target,\n        );\n    }\n    return false;\n  }\n\n  private async evaluateClauses(\n    clauses: Clause[],\n    target: Target,\n  ): Promise<boolean> {\n    for (const clause of clauses) {\n      if ((await this.evaluateClause(clause, target))) {\n        // If any clause returns true we return - rules being treated as OR rather than AND\n        return true;\n      }\n    }\n    // all clauses conditions failed so return false\n    return false;\n  }\n\n  private evaluateRule(rule: ServingRule, target: Target): Promise<boolean> {\n    return this.evaluateClauses(rule.clauses, target);\n  }\n\n  private async evaluateRules(\n    rules: ServingRule[],\n    target: Target,\n  ): Promise<string | undefined> {\n    if (!target || !rules) {\n      return undefined;\n    }\n\n    rules.sort((a: ServingRule, b: ServingRule) =>\n      a.priority > b.priority ? 1 : -1,\n    );\n\n    let identifier: string;\n    for (const rule of rules) {\n      // if evaluation is false just continue to next rule\n      if (!(await this.evaluateRule(rule, target))) {\n        continue;\n      }\n\n      // rule matched, check if there is distribution\n      if (rule.serve.distribution) {\n        identifier = this.evaluateDistribution(rule.serve.distribution, target);\n      }\n\n      // rule matched, here must be variation if distribution is undefined or null\n      if (rule.serve.variation) {\n        identifier = rule.serve.variation;\n      }\n\n      // evaluation succeded, find variation in flag\n      return identifier;\n    }\n    return undefined;\n  }\n\n  private async evaluateVariationMap(\n    variationToTargetMap: VariationMap[],\n    target: Target,\n  ): Promise<string | undefined> {\n    if (!target || !variationToTargetMap) {\n      return undefined;\n    }\n\n    for (const variationMap of variationToTargetMap) {\n      // find target\n      const targetMap = variationMap.targets?.find(\n        (elem) => elem.identifier === target.identifier,\n      );\n      if (targetMap) {\n        return variationMap.variation;\n      }\n\n      // find target in segment\n      const segmentIdentifiers = variationMap.targetSegments;\n      if (\n        segmentIdentifiers &&\n        (await this.isTargetIncludedOrExcludedInSegment(\n          segmentIdentifiers,\n          target,\n        ))\n      ) {\n        return variationMap.variation;\n      }\n    }\n\n    return undefined;\n  }\n\n  private async evaluateFlag(\n    fc: FeatureConfig,\n    target: Target,\n  ): Promise<Variation | undefined> {\n    let variation = fc.offVariation;\n    if (fc.state === FeatureState.On) {\n      variation =\n        (await this.evaluateVariationMap(fc.variationToTargetMap, target)) ||\n        (await this.evaluateRules(fc.rules, target)) ||\n        this.evaluateDistribution(fc.defaultServe.distribution, target) ||\n        fc.defaultServe.variation;\n    }\n    return this.findVariation(fc.variations, variation);\n  }\n\n  private async checkPreRequisite(\n    parent: FeatureConfig,\n    target: Target,\n  ): Promise<boolean> {\n    if (parent.prerequisites) {\n      this.log.info(\n        'Checking pre requisites %s of parent feature %s',\n        parent.prerequisites,\n        parent.feature,\n      );\n\n      for (const pqs of parent.prerequisites) {\n        const preReqFeatureConfig = await this.query.getFlag(pqs.feature);\n        if (!preReqFeatureConfig) {\n          this.log.warn(\n            'Could not retrieve the pre requisite details of feature flag: %s',\n            parent.feature,\n          );\n          return true;\n        }\n\n        // Pre requisite variation value evaluated below\n        const variation = await this.evaluateFlag(preReqFeatureConfig, target);\n        this.log.info(\n          'Pre requisite flag %s has variation %s for target %s',\n          preReqFeatureConfig.feature,\n          variation,\n          target,\n        );\n\n        // Compare if the pre requisite variation is a possible valid value of\n        // the pre requisite FF\n        this.log.info(\n          'Pre requisite flag %s should have the variations %s',\n          preReqFeatureConfig.feature,\n          pqs.variations,\n        );\n\n        if (!pqs.variations.includes(variation.identifier)) {\n          return false;\n        } else {\n          return await this.checkPreRequisite(preReqFeatureConfig, target);\n        }\n      }\n    }\n    return true;\n  }\n\n  private async evaluate(\n    identifier: string,\n    target: Target,\n    expected: FeatureConfigKindEnum,\n    callback?: Callback,\n  ): Promise<Variation | undefined> {\n    const fc = await this.query.getFlag(identifier);\n    if (!fc || fc.kind !== expected) {\n      return undefined;\n    }\n    if (fc.prerequisites) {\n      const prereq = await this.checkPreRequisite(fc, target);\n      if (!prereq) {\n        return this.findVariation(fc.variations, fc.offVariation);\n      }\n    }\n\n    const variation = await this.evaluateFlag(fc, target);\n    if (variation) {\n      if (callback) {\n        callback(fc, target, variation);\n      }\n      return variation;\n    }\n\n    return undefined;\n  }\n\n  async boolVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = false,\n    callback?: Callback,\n  ): Promise<boolean> {\n    const variation = await this.evaluate(\n      identifier,\n      target,\n      FeatureConfigKindEnum.Boolean,\n      callback,\n    );\n    if (variation) {\n      return variation.value.toLowerCase() === 'true';\n    }\n\n    return defaultValue;\n  }\n\n  async stringVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = '',\n    callback?: Callback,\n  ): Promise<string> {\n    const variation = await this.evaluate(\n      identifier,\n      target,\n      FeatureConfigKindEnum.String,\n      callback,\n    );\n    if (variation) {\n      return variation.value;\n    }\n\n    return defaultValue;\n  }\n\n  async numberVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = 0,\n    callback?: Callback,\n  ): Promise<number> {\n    const variation = await this.evaluate(\n      identifier,\n      target,\n      FeatureConfigKindEnum.Int,\n      callback,\n    );\n    if (variation) {\n      return parseFloat(variation.value);\n    }\n\n    return defaultValue;\n  }\n\n  async jsonVariation(\n    identifier: string,\n    target: Target,\n    defaultValue = {},\n    callback?: Callback,\n  ): Promise<Record<string, unknown>> {\n    const variation = await this.evaluate(\n      identifier,\n      target,\n      FeatureConfigKindEnum.Json,\n      callback,\n    );\n    if (variation) {\n      return JSON.parse(variation.value);\n    }\n\n    return defaultValue;\n  }\n}\n", "import EventEmitter from 'events';\nimport { SEGMENT_MATCH_OPERATOR } from './constants';\nimport { FeatureConfig, Segment } from './openapi';\nimport { AsyncKeyValueStore, KeyValueStore, Query } from './types';\n\nexport interface Repository extends Query {\n  // put values\n  setFlag(identifier: string, fc: FeatureConfig): Promise<void>;\n  setSegment(identifier: string, segment: Segment): Promise<void>;\n\n  // remove values\n  deleteFlag(identifier: string): Promise<void>;\n  deleteSegment(identifier: string): Promise<void>;\n}\n\nexport enum RepositoryEvent {\n  FLAG_STORED = 'flag_stored',\n  FLAG_DELETED = 'flag_deleted',\n  SEGMENT_STORED = 'segment_stored',\n  SEGMENT_DELETED = 'segment_deleted',\n}\n\nexport class StorageRepository implements Repository {\n  private cache: KeyValueStore;\n  private store: AsyncKeyValueStore;\n  private eventBus: EventEmitter;\n\n  constructor(\n    cache: KeyValueStore,\n    store?: AsyncKeyValueStore,\n    eventBus?: EventEmitter,\n  ) {\n    if (!cache) {\n      throw new Error('Cache is required argument and cannot be undefined');\n    }\n    this.eventBus = eventBus;\n    this.cache = cache;\n    this.store = store;\n  }\n\n  async setFlag(identifier: string, fc: FeatureConfig): Promise<void> {\n    if (await this.isFlagOutdated(identifier, fc)) {\n      return;\n    }\n    const flagKey = this.formatFlagKey(identifier);\n    if (this.store) {\n      await this.store.set(flagKey, fc);\n      this.cache.del(flagKey);\n    } else {\n      this.cache.set(flagKey, fc);\n    }\n    if (this.eventBus) {\n      this.eventBus.emit(RepositoryEvent.FLAG_STORED, identifier);\n    }\n  }\n\n  async setSegment(identifier: string, segment: Segment): Promise<void> {\n    if (await this.isSegmentOutdated(identifier, segment)) {\n      return;\n    }\n    const segmentKey = this.formatSegmentKey(identifier);\n    if (this.store) {\n      await this.store.set(segmentKey, segment);\n      this.cache.del(segmentKey);\n    } else {\n      this.cache.set(segmentKey, segment);\n    }\n    if (this.eventBus) {\n      this.eventBus.emit(RepositoryEvent.SEGMENT_STORED, identifier);\n    }\n  }\n\n  async deleteFlag(identifier: string): Promise<void> {\n    const flagKey = this.formatFlagKey(identifier);\n    if (this.store) {\n      await this.store.del(flagKey);\n    }\n    this.cache.del(flagKey);\n    if (this.eventBus) {\n      this.eventBus.emit(RepositoryEvent.FLAG_DELETED, identifier);\n    }\n  }\n\n  async deleteSegment(identifier: string): Promise<void> {\n    const segmentKey = this.formatSegmentKey(identifier);\n    if (this.store) {\n      await this.store.del(segmentKey);\n    }\n    this.cache.del(segmentKey);\n    if (this.eventBus) {\n      this.eventBus.emit(RepositoryEvent.SEGMENT_DELETED, identifier);\n    }\n  }\n\n  async getFlag(identifier: string, cacheable = true): Promise<FeatureConfig> {\n    const flagKey = this.formatFlagKey(identifier);\n    let flag = this.cache.get(flagKey) as FeatureConfig;\n    if (flag) {\n      return flag;\n    }\n    if (this.store) {\n      flag = await this.store.get<FeatureConfig>(flagKey);\n      if (flag && cacheable) {\n        this.cache.set(flagKey, flag);\n      }\n      return flag;\n    }\n    return undefined;\n  }\n\n  async getSegment(identifier: string, cacheable = true): Promise<Segment> {\n    const segmentKey = this.formatSegmentKey(identifier);\n    let segment = this.cache.get(segmentKey) as Segment;\n    if (segment) {\n      return segment;\n    }\n    if (this.store) {\n      segment = await this.store.get<Segment>(segmentKey);\n      if (segment && cacheable) {\n        this.cache.set(segmentKey, segment);\n      }\n      return segment;\n    }\n    return undefined;\n  }\n\n  async findFlagsBySegment(segment: string): Promise<string[]> {\n    const result = [];\n    let keys = this.cache.keys();\n    if (this.store) {\n      keys = await this.store.keys();\n    }\n    for (const key of keys) {\n      const flag = await this.getFlag(key);\n      if (!flag) {\n        return [];\n      }\n      for (const rule of flag?.rules) {\n        for (const clause of rule?.clauses) {\n          if (\n            clause.op === SEGMENT_MATCH_OPERATOR &&\n            clause.values.includes(segment)\n          ) {\n            result.push(flag.feature);\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  private async isFlagOutdated(\n    key: string,\n    flag: FeatureConfig,\n  ): Promise<boolean> {\n    const oldFlag = await this.getFlag(key, false); // dont set cacheable, we are just checking the version\n    return oldFlag?.version && oldFlag.version >= flag?.version;\n  }\n\n  private async isSegmentOutdated(\n    key: string,\n    segment: Segment,\n  ): Promise<boolean> {\n    const oldSegment = await this.getSegment(key, false); // dont set cacheable, we are just checking the version\n    return oldSegment?.version && oldSegment.version >= segment?.version;\n  }\n\n  private formatFlagKey(key: string): string {\n    return `flags/${key}`;\n  }\n\n  private formatSegmentKey(key: string): string {\n    return `segments/${key}`;\n  }\n}\n", "import * as events from 'events';\nimport {\n  FEATURE_IDENTIFIER_ATTRIBUTE,\n  FEATURE_NAME_ATTRIBUTE,\n  GLOBAL_TARGET,\n  SDK_LANGUAGE,\n  SDK_LANGUAGE_ATTRIBUTE,\n  SDK_TYPE,\n  SDK_TYPE_ATTRIBUTE,\n  SDK_VERSION_ATTRIBUTE,\n  TARGET_ATTRIBUTE,\n  VARIATION_IDENTIFIER_ATTRIBUTE,\n} from './constants';\nimport {\n  Configuration,\n  FeatureConfig,\n  Metrics,\n  MetricsApi,\n  Variation,\n  TargetData,\n  KeyValue,\n  MetricsData,\n  MetricsDataMetricsTypeEnum,\n} from './openapi';\nimport { Options, Target } from './types';\nimport { VERSION } from './version';\n\nexport enum MetricEvent {\n  READY = 'metrics_ready',\n  ERROR = 'metrics_error',\n}\n\ninterface AnalyticsEvent {\n  target: Target;\n  featureConfig: FeatureConfig;\n  variation: Variation;\n  count: number;\n}\n\nexport interface MetricsProcessorInterface {\n  start(): void;\n  close(): void;\n  enqueue(\n    target: Target,\n    featureConfig: FeatureConfig,\n    variation: Variation,\n  ): void;\n}\n\nexport const MetricsProcessor = (\n  environment: string,\n  cluster = '1',\n  conf: Configuration,\n  options: Options,\n  eventBus: events.EventEmitter,\n): MetricsProcessorInterface => {\n  const data: Map<string, AnalyticsEvent> = new Map<string, AnalyticsEvent>();\n  let syncInterval: NodeJS.Timeout;\n\n  const configuration = new Configuration({\n    ...conf,\n    basePath: options.eventsUrl,\n  });\n  const api = new MetricsApi(configuration);\n  const log = options.logger;\n\n  const enqueue = (\n    target: Target,\n    featureConfig: FeatureConfig,\n    variation: Variation,\n  ): void => {\n    const event: AnalyticsEvent = {\n      target,\n      featureConfig,\n      variation,\n      count: 0,\n    };\n\n    const key = _formatKey(event);\n    const found = data.get(key);\n    if (found) {\n      found.count++;\n    } else {\n      event.count = 1;\n      data.set(key, event);\n    }\n  };\n\n  const _formatKey = (event: AnalyticsEvent): string => {\n    const feature = event.featureConfig.feature;\n    const variation = event.variation.identifier;\n    const value = event.variation.value;\n    const target = GLOBAL_TARGET;\n    return `${feature}/${variation}/${value}/${target}`;\n  };\n\n  const _summarize = (): Metrics | unknown => {\n    if (!data) {\n      log.debug('No metrics data!');\n      return;\n    }\n\n    const targetData: TargetData[] = [];\n    const metricsData: MetricsData[] = [];\n\n    // clone map and clear data\n    const clonedData = new Map(data);\n    data.clear();\n\n    for (const event of clonedData.values()) {\n      if (event.target && !event.target.anonymous) {\n        let targetAttributes: KeyValue[] = [];\n        if (event.target.attributes) {\n          targetAttributes = Object.entries(event.target.attributes).map(\n            ([key, value]) => ({ key, value: value as string }),\n          );\n        }\n        let targetName = event.target.identifier;\n        if (event.target.name) {\n          targetName = event.target.name;\n        }\n\n        const td: TargetData = {\n          identifier: event.target.identifier,\n          name: targetName,\n          attributes: targetAttributes,\n        };\n        targetData.push(td);\n      }\n\n      const metricsAttributes: KeyValue[] = [\n        {\n          key: FEATURE_IDENTIFIER_ATTRIBUTE,\n          value: event.featureConfig.feature,\n        },\n        {\n          key: FEATURE_NAME_ATTRIBUTE,\n          value: event.featureConfig.feature,\n        },\n        {\n          key: VARIATION_IDENTIFIER_ATTRIBUTE,\n          value: event.variation.identifier,\n        },\n        {\n          key: SDK_TYPE_ATTRIBUTE,\n          value: SDK_TYPE,\n        },\n        {\n          key: SDK_LANGUAGE_ATTRIBUTE,\n          value: SDK_LANGUAGE,\n        },\n        {\n          key: SDK_VERSION_ATTRIBUTE,\n          value: VERSION,\n        },\n        {\n          key: TARGET_ATTRIBUTE,\n          value: event?.target?.identifier ?? null,\n        },\n      ];\n\n      // private target attributes\n      // need more info\n\n      const md: MetricsData = {\n        timestamp: Date.now(),\n        count: event.count,\n        metricsType: MetricsDataMetricsTypeEnum.Ffmetrics,\n        attributes: metricsAttributes,\n      };\n      metricsData.push(md);\n    }\n    return {\n      targetData: targetData,\n      metricsData: metricsData,\n    };\n  };\n\n  const _send = (): void => {\n    const metrics: Metrics = _summarize();\n    if (metrics) {\n      log.debug('Start sending metrics data');\n      api\n        .postMetrics(environment, cluster, metrics)\n        .then((response) => {\n          log.debug('Metrics server returns: ', response.status);\n          if (response.status >= 400) {\n            log.error(\n              'Error while sending metrics data with status code: ',\n              response.status,\n            );\n          }\n        })\n        .catch((error: Error) => {\n          log.debug('Metrics server returns error: ', error);\n        });\n    }\n  };\n\n  const start = (): void => {\n    log.info(\n      'Starting MetricsProcessor with request interval: ',\n      options.eventsSyncInterval,\n    );\n    syncInterval = setInterval(_send, options.eventsSyncInterval);\n    eventBus.emit(MetricEvent.READY);\n  };\n\n  const close = (): void => {\n    log.info('Closing MetricsProcessor');\n    clearInterval(syncInterval);\n    _send();\n    log.info('MetricsProcessor closed');\n  };\n\n  return {\n    start,\n    close,\n    enqueue,\n  };\n};\n", "import Client, { Event } from './client';\nimport LRU from 'lru-cache';\nimport { Options, Target } from './types';\nimport { Logger } from './log';\nimport { AsyncKeyValueStore, KeyValueStore } from './types';\nimport { FileStore } from './store';\n\nexport {\n  Client,\n  Event,\n  Options,\n  Target,\n  AsyncKeyValueStore,\n  KeyValueStore,\n  Logger,\n  LRU,\n  FileStore,\n};\nexport default {\n  instance: undefined,\n  init: function (sdkKey: string, options: Options): void {\n    if (!this.instance) {\n      this.instance = new Client(sdkKey, options);\n    }\n  },\n  waitForInitialization: function (): Promise<Client> {\n    return this.instance.waitForInitialization();\n  },\n  boolVariation: function (\n    identifier: string,\n    target: Target,\n    defaultValue = false,\n  ): Promise<boolean> {\n    return this.instance.boolVariation(identifier, target, defaultValue);\n  },\n  stringVariation: function (\n    identifier: string,\n    target: Target,\n    defaultValue = '',\n  ): Promise<string> {\n    return this.instance.stringVariation(identifier, target, defaultValue);\n  },\n  numberVariation: function (\n    identifier: string,\n    target: Target,\n    defaultValue = 0,\n  ): Promise<number> {\n    return this.instance.numberVariation(identifier, target, defaultValue);\n  },\n  jsonVariation: function (\n    identifier: string,\n    target: Target,\n    defaultValue = '',\n  ): Promise<Record<string, unknown>> {\n    return this.instance.jsonVariation(identifier, target, defaultValue);\n  },\n  on: function (event: Event, callback: (...args: unknown[]) => void): void {\n    this.instance.on(event, callback);\n  },\n  off: function (event?: Event, callback?: () => void): void {\n    this.instance.off(event, callback);\n  },\n  close: function (): void {\n    return this.instance.close();\n  },\n};\n"],
  "mappings": "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",
  "names": []
}
